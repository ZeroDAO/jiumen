import{n as v}from"./nanoid-86c80500.js";const y=Symbol("abortable"),p=Symbol("aborted");function O(n,e){if(e.aborted)return Promise.reject(p);let t;const s=new Promise((u,l)=>{t=l});return e.addEventListener("abort",()=>{t(p)}),Promise.race([n,s])}const T="utils_abort_request";var a;(function(n){n[n.PARSE_ERROR=-32700]="PARSE_ERROR",n[n.INVALID_REQUEST=-32600]="INVALID_REQUEST",n[n.METHOD_NOT_FOUND=-32601]="METHOD_NOT_FOUND",n[n.INVALID_PARAMS=-32602]="INVALID_PARAMS",n[n.INTERNAL_ERROR=-32603]="INTERNAL_ERROR"})(a||(a={}));const m={[a.PARSE_ERROR]:"Parse error",[a.INVALID_REQUEST]:"Invalid request",[a.METHOD_NOT_FOUND]:"Method not found",[a.INVALID_PARAMS]:"Invalid params",[a.INTERNAL_ERROR]:"Internal error"};function P(n){return-32e3>=n&&n>=-32099}function R(n){return m[n.toString()]??(P(n)?"Server error":"Application error")}class f extends Error{static fromObject(e){return new f(e.code,e.message,e.data)}toObject(){return{code:this.code,data:this.data,message:this.message}}constructor(e,t,s){super(),Object.setPrototypeOf(this,f.prototype),this.code=e,this.data=s,this.message=t??R(e)}}function b(n){const e=m[n];return function(s){return new f(n,e,s)}}b(a.PARSE_ERROR);b(a.INVALID_REQUEST);b(a.METHOD_NOT_FOUND);b(a.INVALID_PARAMS);b(a.INTERNAL_ERROR);function D(n,e){if(e.has(n))throw new TypeError("Cannot initialize the same private elements twice on an object")}function M(n,e){return e.get?e.get.call(n):e.value}function g(n,e,t){if(e.set)e.set.call(n,t);else{if(!e.writable)throw new TypeError("attempted to set read only private field");e.value=t}}function w(n,e,t){if(!e.has(n))throw new TypeError("attempted to "+t+" private field on non-instance");return e.get(n)}function N(n,e){var t=w(n,e,"get");return M(n,t)}function L(n,e,t){D(n,e),e.set(n,t)}function j(n,e,t){var s=w(n,e,"set");return g(n,s,t),t}var _=new WeakMap;class Q{get connection(){return N(this,_)}createID(){return v()}request(e,t=void 0,s={}){const{signal:u}=s;if(u?.aborted)return Promise.reject(p);const l=this.createID(),A=N(this,_).send({jsonrpc:"2.0",id:l,method:e,params:t}).then(d=>{if(d==null)throw new Error("Missing response");if(d.error!=null)throw f.fromObject(d.error);return d.result});return u==null?A:(u.addEventListener("abort",()=>{this.notify(T,{id:l})}),O(A,u))}async notify(e,t=void 0){await N(this,_).send({jsonrpc:"2.0",method:e,params:t})}constructor(e){L(this,_,{writable:!0,value:void 0}),j(this,_,e)}}function S(n,e){return{jsonrpc:"2.0",id:n,error:{code:e,message:R(e)}}}function U(n,e,t){console.warn("Unhandled handler error",e,t)}function H(n,e){console.warn("Unhandled invalid message",e)}function F(n,e){console.warn("Unhandled notification",e)}function k(n,e={}){const t=e.onHandlerError??U,s=e.onInvalidMessage??H,u=e.onNotification??F,l={};function A(d,c){if(c.method===T){const i=c.params?.id;i!=null&&l[i]?.abort()}else u(d,c)}return async function(c,i){const r=i.id;if(i.jsonrpc!=="2.0"||i.method==null)return r==null?(s(c,i),null):S(r,a.INVALID_REQUEST);const I=n[i.method];if(I==null)return r==null?(A(c,i),null):S(r,a.METHOD_NOT_FOUND);try{let o;if(r!=null&&I[y]){const E=new AbortController;l[r]=E,o=I(c,i.params,{signal:E.signal})}else o=I(c,i.params,{});const h=o==null?o:typeof o.then=="function"?await o:o;return r==null||l[r]?.signal.aborted?null:{jsonrpc:"2.0",id:r,result:h}}catch(o){if(r==null||l[r]?.signal.aborted)return t(c,i,o),null;let h;if(o instanceof f)h=o.toObject();else{t(c,i,o);const E=o.code??-32e3;h={code:E,message:o.message||R(E)}}return{jsonrpc:"2.0",id:r,error:h}}finally{r!=null&&delete l[r]}}}export{Q as R,f as a,k as c};
