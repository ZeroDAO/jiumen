import{A as J}from"./caip-9ca4a743.js";import{c as Nt,f as C,t as T}from"./uint8arrays-499feafe.js";import{r as dt,s as le}from"./@stablelib-7cabded6.js";import{S as ue,C as me}from"./@didtools-9ec565e1.js";import"./inherits-c31b4f37.js";import{S as he,a as fe,p as at,m as W,b as lt,c as Lt,t as pe,d as ge,f as kt,O as Ut,e as ye,g as Ft,B as we,h as Ee}from"./rxjs-39c6337d.js";import{R as Se,c as _e}from"./rpc-utils-50b1abf6.js";import{C as D,d as be,b as q,e as De,s as Ie,c as Re}from"./multiformats-412ad19c.js";import{f as jt}from"./cross-fetch-aa52e6a1.js";import{l as Ce}from"./lru_map-1b96baad.js";import{v as U}from"./varint-034dba75.js";import{d as Te,e as ut,c as pt}from"./@ipld-966a175d.js";import{M as I}from"./mapmoize-30a3511b.js";import{c as v}from"./lodash.clonedeep-ad7d3f3b.js";import{p as Ae}from"./did-resolver-55098980.js";import{s as ve}from"./multihashes-a1289479.js";import{j as qt}from"./fast-json-patch-58abc6e9.js";function $e(n,t=!0){const e={message:`Link this account to your identity

`+n};return t&&(e.timestamp=Math.floor(Date.now()/1e3),e.message+=` 
Timestamp: `+e.timestamp),e}function Pe(n,t){return{jsonrpc:"2.0",id:1,method:n,params:t}}function Bt(n){return`${n.address}@${n.chainId.namespace}:${n.chainId.reference}`}const Gt={tile:0,"caip10-link":1,model:2,MID:3,UNLOADABLE:4};function Oe(n){const t=Gt[n];if(typeof t<"u")return t;throw new Error(`No stream type registered for name ${n}`)}function Me(n){const t=Object.entries(Gt).find(([,e])=>e===n);if(t)return t[0];throw new Error(`No stream type registered for index ${n}`)}class ${}$.nameByCode=Me;$.codeByName=Oe;const mt=206;function V(n){try{return n()}catch(t){return t}}function k(n){const t=U.decode(n),e=U.decode.bytes,r=n.subarray(e);return[t,r,e]}function xe(n){return n===0||n===1}function gt(n){const[t,e]=k(n);if(!xe(t))throw new Error(`Unknown CID version ${t}`);const[r,i]=k(e),[,s,o]=k(i),[a,,d]=k(s),l=i.subarray(0,o+d+a),y=i.subarray(o+d+a);return[D.create(t,r,be(l)),y]}function Q(n,t="StreamRef"){const[e,r]=k(n);if(e!==mt)throw new Error(`Invalid ${t}, does not include streamid codec`);const[i,s]=k(r),o=gt(s),[a,d]=o;if(d.length===0)return{kind:"stream-id",type:i,genesis:a};if(d.length===1&&d[0]===0)return{kind:"commit-id",type:i,genesis:a,commit:null};{const[l]=gt(d);return{kind:"commit-id",type:i,genesis:a,commit:l}}}const Ne=/(ceramic:\/\/|\/ceramic\/)?([a-zA-Z0-9]+)(\?commit=([a-zA-Z0-9]+))?/;function ht(n,t="StreamRef"){const e=Ne.exec(n)||[],r=e[2];if(!r)throw new Error(`Malformed ${t} string: ${n}`);const i=q.decode(r),s=Q(i),o=e[4];return o?{kind:"commit-id",type:s.type,genesis:s.genesis,commit:Yt(s.genesis,o)}:s}function Le(n){try{return typeof n=="string"?D.parse(n):D.asCID(n)}catch{return null}}function Yt(n,t=null){if(!t||t==="0")return null;const e=Le(t);if(e)return n.equals(e)?null:e;throw new Error("Cannot specify commit as a number except to request commit 0 (the genesis commit)")}var Y=globalThis&&globalThis.__decorate||function(n,t,e,r){var i=arguments.length,s=i<3?t:r===null?r=Object.getOwnPropertyDescriptor(t,e):r,o;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")s=Reflect.decorate(n,t,e,r);else for(var a=n.length-1;a>=0;a--)(o=n[a])&&(s=(i<3?o(s):i>3?o(t,e,s):o(t,e))||s);return i>3&&s&&Object.defineProperty(t,e,s),s},S=globalThis&&globalThis.__metadata||function(n,t){if(typeof Reflect=="object"&&typeof Reflect.metadata=="function")return Reflect.metadata(n,t)};class ke extends Error{constructor(t){super(`Invalid StreamID bytes ${q.encode(t)}: contains commit`)}}class Ue extends Error{constructor(t){super(`Invalid StreamID string ${t}: contains commit`)}}function Ht(n){const t=Q(n,"StreamID");if(t.kind==="stream-id")return new c(t.type,t.genesis);throw new ke(n)}function Fe(n){return V(()=>Ht(n))}function Jt(n){const t=ht(n,"StreamID");if(t.kind==="stream-id")return new c(t.type,t.genesis);throw new Ue(n)}function je(n){return V(()=>Jt(n))}const yt=Symbol.for("@ceramicnetwork/streamid/StreamID");class c{constructor(t,e){if(this._tag=yt,!(t||t===0))throw new Error("StreamID constructor: type required");if(!e)throw new Error("StreamID constructor: cid required");this._type=typeof t=="string"?$.codeByName(t):t,this._cid=typeof e=="string"?D.parse(e):e}static isInstance(t){return typeof t=="object"&&"_tag"in t&&t._tag===yt}static async fromGenesis(t,e){const r=await De({value:e,codec:Te,hasher:Ie});return new c(t,r.cid)}get type(){return this._type}get typeName(){return $.nameByCode(this._type)}get cid(){return this._cid}get bytes(){const t=U.encode(mt),e=U.encode(this.type);return Nt([t,e,this.cid.bytes])}get baseID(){return new c(this._type,this._cid)}equals(t){return c.isInstance(t)?this.type===t.type&&this.cid.equals(t.cid):!1}toString(){return q.encode(this.bytes)}toUrl(){return`ceramic://${this.toString()}`}[Symbol.for("nodejs.util.inspect.custom")](){return`StreamID(${this.toString()})`}[Symbol.toPrimitive](){return this.toString()}}c.fromBytes=Ht;c.fromBytesNoThrow=Fe;c.fromString=Jt;c.fromStringNoThrow=je;Y([I(),S("design:type",String),S("design:paramtypes",[])],c.prototype,"typeName",null);Y([I(),S("design:type",Uint8Array),S("design:paramtypes",[])],c.prototype,"bytes",null);Y([I(),S("design:type",c),S("design:paramtypes",[])],c.prototype,"baseID",null);Y([I(),S("design:type",Function),S("design:paramtypes",[]),S("design:returntype",String)],c.prototype,"toString",null);Y([I(),S("design:type",Function),S("design:paramtypes",[]),S("design:returntype",String)],c.prototype,"toUrl",null);var B=globalThis&&globalThis.__decorate||function(n,t,e,r){var i=arguments.length,s=i<3?t:r===null?r=Object.getOwnPropertyDescriptor(t,e):r,o;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")s=Reflect.decorate(n,t,e,r);else for(var a=n.length-1;a>=0;a--)(o=n[a])&&(s=(i<3?o(s):i>3?o(t,e,s):o(t,e))||s);return i>3&&s&&Object.defineProperty(t,e,s),s},p=globalThis&&globalThis.__metadata||function(n,t){if(typeof Reflect=="object"&&typeof Reflect.metadata=="function")return Reflect.metadata(n,t)},tt=globalThis&&globalThis.__classPrivateFieldSet||function(n,t,e,r,i){if(r==="m")throw new TypeError("Private method is not writable");if(r==="a"&&!i)throw new TypeError("Private accessor was defined without a setter");if(typeof t=="function"?n!==t||!i:!t.has(n))throw new TypeError("Cannot write private member to an object whose class did not declare it");return r==="a"?i.call(n,e):i?i.value=e:t.set(n,e),e},R=globalThis&&globalThis.__classPrivateFieldGet||function(n,t,e,r){if(e==="a"&&!r)throw new TypeError("Private accessor was defined without a getter");if(typeof t=="function"?n!==t||!r:!t.has(n))throw new TypeError("Cannot read private member from an object whose class did not declare it");return e==="m"?r:e==="a"?r.call(n):r?r.value:t.get(n)},L,P,G;class qe extends Error{constructor(t){super(`Error while parsing CommitID from bytes ${q.encode(t)}: no commit information provided`)}}class Be extends Error{constructor(t){super(`Error while parsing CommitID from string ${t}: no commit information provided`)}}function Wt(n){const t=Q(n,"CommitID");if(t.kind==="commit-id")return new u(t.type,t.genesis,t.commit);throw new qe(n)}function Ge(n){return V(()=>Wt(n))}function zt(n){const t=ht(n,"CommitID");if(t.kind==="commit-id")return new u(t.type,t.genesis,t.commit);throw new Be(n)}function Ye(n){return V(()=>zt(n))}const wt=Symbol.for("@ceramicnetwork/streamid/CommitID");function He(n,t){return new u(n.type,n.cid,t)}class u{constructor(t,e,r=null){if(this._tag=wt,L.set(this,void 0),P.set(this,void 0),G.set(this,void 0),!t&&t!==0)throw new Error("constructor: type required");if(!e)throw new Error("constructor: cid required");tt(this,L,typeof t=="string"?$.codeByName(t):t,"f"),tt(this,P,typeof e=="string"?D.parse(e):e,"f"),tt(this,G,Yt(R(this,P,"f"),r),"f")}static isInstance(t){return typeof t=="object"&&"_tag"in t&&t._tag===wt}get baseID(){return new c(R(this,L,"f"),R(this,P,"f"))}get type(){return R(this,L,"f")}get typeName(){return $.nameByCode(R(this,L,"f"))}get cid(){return R(this,P,"f")}get commit(){return R(this,G,"f")||R(this,P,"f")}get bytes(){const t=U.encode(mt),e=U.encode(this.type),r=R(this,G,"f")?.bytes||new Uint8Array([0]);return Nt([t,e,this.cid.bytes,r])}equals(t){return this.type===t.type&&this.cid.equals(t.cid)&&this.commit.equals(t.commit)}toString(){return q.encode(this.bytes)}toUrl(){return`ceramic://${this.toString()}`}[(L=new WeakMap,P=new WeakMap,G=new WeakMap,Symbol.for("nodejs.util.inspect.custom"))](){return`CommitID(${this.toString()})`}[Symbol.toPrimitive](){return this.toString()}}u.fromBytes=Wt;u.fromBytesNoThrow=Ge;u.fromString=zt;u.fromStringNoThrow=Ye;u.make=He;B([I(),p("design:type",c),p("design:paramtypes",[])],u.prototype,"baseID",null);B([I(),p("design:type",String),p("design:paramtypes",[])],u.prototype,"typeName",null);B([I(),p("design:type",D),p("design:paramtypes",[])],u.prototype,"commit",null);B([I(),p("design:type",Uint8Array),p("design:paramtypes",[])],u.prototype,"bytes",null);B([I(),p("design:type",Function),p("design:paramtypes",[]),p("design:returntype",String)],u.prototype,"toString",null);B([I(),p("design:type",Function),p("design:paramtypes",[]),p("design:returntype",String)],u.prototype,"toUrl",null);var M;(function(n){function t(i){const s=Q(i);switch(s.kind){case"commit-id":return new u(s.type,s.genesis,s.commit);case"stream-id":return new c(s.type,s.genesis);default:throw new Error(`Malformed StreamRef bytes: ${q.encode(i)}`)}}n.fromBytes=t;function e(i){const s=ht(i);switch(s.kind){case"commit-id":return new u(s.type,s.genesis,s.commit);case"stream-id":return new c(s.type,s.genesis);default:throw new Error(`Malformed StreamRef string: ${i}`)}}n.fromString=e;function r(i){if(c.isInstance(i)||u.isInstance(i))return i;if(i instanceof Uint8Array)return t(i);if(typeof i=="string")return e(i);throw new Error(`Can not build CommitID or StreamID from ${JSON.stringify(i)}`)}n.from=r})(M||(M={}));const Kt={ethereumEOA:"ethereum-eoa",erc1271:"erc1271"},Je="eip155",Et=new WeakMap;async function Vt(n){let t=Et.get(n);if(!t){const e=await H(n,"eth_chainId",[]);t=parseInt(e,16),Et.set(n,t)}return t}class Qt{constructor(t,e,r={}){this.provider=t,this.address=e,this.opts=r,this.isAuthProvider=!0}async accountId(){if(!this._accountId){const t=await Vt(this.provider);this._accountId=new J({address:this.address,chainId:`${Je}:${t}`})}return this._accountId}async authenticate(t){const e=await this.accountId();return Ze(t,e,this.provider)}async createLink(t){const e=await this.accountId();return Qe(t,e,this.provider,this.opts)}async requestCapability(t,e,r={}){console.warn("WARN: requestCapability os an experimental API, that is subject to change any time.");const i=typeof window<"u"?window.location.hostname:r.domain;if(!i)throw new Error("Missing parameter 'domain'");const s=new Date,o=new Date(s.getTime()+24*60*60*1e3),a=new ue({domain:i,address:this.address,statement:r.statement??"Give this application access to some of your data on Ceramic",uri:t,version:r.version??"1",nonce:r.nonce??dt.randomString(10),issuedAt:s.toISOString(),expirationTime:r.expirationTime??o.toISOString(),chainId:(await this.accountId()).chainId.reference,resources:(r.resources??[]).concat(e.map(h=>(typeof h=="string"?c.fromString(h):h).toUrl()))});r.requestId&&(a.requestId=r.requestId);const d=await this.accountId(),l=await H(this.provider,"personal_sign",[a.signMessage(),d.address]);return a.signature=l,me.fromSiweMessage(a)}withAddress(t){return new Qt(this.provider,t)}}async function We(n,t){return H(t,"eth_getCode",[n,"latest"])}function H(n,t,e){if(e==null&&(e=[]),n.request)return n.request({method:t,params:e}).then(r=>r,r=>{throw r});if(n.sendAsync||n.send){const r=(n.sendAsync?n.sendAsync:n.send).bind(n),i=Pe(t,e);return new Promise((s,o)=>{r(i,(a,d)=>{if(a&&o(a),d.error){const l=new Error(d.error.message);l.code=d.error.code,l.data=d.error.data,o(l)}s(d.result)})})}else throw new Error("Unsupported provider; provider must implement one of the following methods: send, sendAsync, request")}async function ze(n,t){const e=await We(n.address,t).catch(()=>null);return Boolean(e&&e!=="0x"&&e!=="0x0"&&e!=="0x00")}function Zt(n){return new J({address:n.address.toLowerCase(),chainId:n.chainId})}function Xt(n){const t=C(n),e=T(t,"base16");return"0x"+e}async function te(n,t,e,r={}){const{message:i,timestamp:s}=$e(n,!r.skipTimestamp),o=Xt(i),a=await H(e,"personal_sign",[o,t.address]),d={version:2,type:Kt.ethereumEOA,message:i,signature:a,account:Bt(t)};return r.skipTimestamp||(d.timestamp=s),d}async function Ke(n,t){const e=await Vt(t);if(e!==parseInt(n.chainId.reference))throw new Error(`ChainId in provider (${e}) is different from AccountId (${n.chainId.reference})`)}async function Ve(n,t,e,r){const i=r?.eoaSignAccount||t,s=await te(n,i,e,r);return await Ke(t,e),Object.assign(s,{type:Kt.erc1271,account:Bt(t)})}async function Qe(n,t,e,r){return t=Zt(t),await ze(t,e)?Ve(n,t,e,r):te(n,t,e,r)}async function Ze(n,t,e){if(t&&(t=Zt(t)),e.isAuthereum)return e.signMessageWithSigningKey(n);const r=Xt(n),i=await H(e,"personal_sign",[r,t.address]),s=C(i.slice(2)),o=le.hash(s);return`0x${T(o,"base16")}`}class Xe extends he{next(t){this._sink.next?.(t)}error(t){this._sink.error?.(t)}complete(){this._sink.complete?.()}_subscribe(t){return this._source.subscribe(t)??fe.EMPTY}constructor(t,e){super(),this._source=t,this._sink=e}}function ee(n){return function(e){return{__tw:!0,ns:n,msg:e}}}function ne(n){return function(e){if(e.__tw!==!0)throw new Error("Input is not a wrapped message");if(typeof e.ns!="string")throw new Error(`Invalid namespace type for wrapped message: expected a string, got ${typeof e.ns}`);if(e.ns!==n)throw new Error(`Invalid namespace for wrapped message: expected ${n}, got ${e.ns}`);return e.msg}}function tn(n){return{wrap:ee(n),unwrap:ne(n)}}function en(n,t={}){if(t.throwWhenInvalid)return at(W(n));const e=typeof t.onInvalidInput=="function"?t.onInvalidInput:function(i,s){console.warn("Invalid transport input",i,s)};return at(W(r=>{try{return n(r)}catch(i){return e(r,i),null}}),lt(r=>r!==null))}function nn(n,t){return{...n,next:e=>{e!=null&&n.next(t(e))}}}function rn(n){return Array.isArray(n)||(n=[n]),t=>n.includes(t.origin)}function re(n,t){const e=Lt(n,"message");if(t==null)return e;const r=typeof t=="function"?t:rn(t);return e.pipe(lt(r))}function sn(n,...t){return{next:e=>{e!=null&&n.postMessage(e,...t)}}}function on(n,t=n,e={}){const r=e.postMessageArguments??[],i=re(n,e.filter),s=sn(t,...r);return new Xe(i,s)}function an(n,t,e={}){const r=_e(n,e),i=ne(t);return at(W(s=>{try{const o=i(s.data);return o.method?{type:"request",message:s,request:o}:null}catch{return null}}),lt(s=>s!==null),ge(async s=>({type:"handled",message:s.message,request:s.request,response:await r(s.message,s.request)})))}function cn({filter:n,methods:t,namespace:e,target:r,...i}){const s=ee(e);return re(r,n).pipe(an(t,e,i),pe(o=>{o.response!=null&&(o.message.source??window).postMessage(s(o.response),o.message.origin||"*")}))}function dn(n,t,e){const r=tn(t),i=nn(n,r.wrap),s=en(r.unwrap,e);return async function(a){return new Promise((d,l)=>{const y=n.pipe(W(h=>h.data),s,kt(h=>h!=null&&h.id===a.id&&("error"in h||"result"in h))).subscribe({next:h=>{d(h),y.unsubscribe()},error:l});i.next(a)})}}function ln(n,t,e){const r=dn(n,t,e);return new Se({send:r})}const un={onInvalidInput:(n,t)=>{},postMessageArguments:["*"]};function pr(n,t=window,e=un){const r=on(window,t,e);return ln(r,n,e)}function gr(n,t,e=window){return cn({methods:t,namespace:n,target:e})}var f;(function(n){n[n.PREFER_CACHE=0]="PREFER_CACHE",n[n.SYNC_ALWAYS=1]="SYNC_ALWAYS",n[n.NEVER_SYNC=2]="NEVER_SYNC",n[n.SYNC_ON_ERROR=3]="SYNC_ON_ERROR"})(f||(f={}));var St;(function(n){n[n.GENESIS=0]="GENESIS",n[n.PARTIAL=1]="PARTIAL",n[n.SIGNED=2]="SIGNED"})(St||(St={}));var z;(function(n){n[n.NOT_REQUESTED=0]="NOT_REQUESTED",n[n.PENDING=1]="PENDING",n[n.PROCESSING=2]="PROCESSING",n[n.ANCHORED=3]="ANCHORED",n[n.FAILED=4]="FAILED"})(z||(z={}));var K;(function(n){n[n.GENESIS=0]="GENESIS",n[n.SIGNED=1]="SIGNED",n[n.ANCHOR=2]="ANCHOR"})(K||(K={}));class Z extends Ut{constructor(t,e){super(r=>{t.subscribe(r)}),this.state$=t,this._context=e}get id(){return new c(this.state$.value.type,this.state$.value.log[0].cid)}get api(){return this._context.api}get content(){const{next:t,content:e}=this.state$.value;return v(t?.content??e)}get tip(){return this.state$.value.log[this.state$.value.log.length-1].cid}get commitId(){return u.make(this.id,this.tip)}get allCommitIds(){return this.state$.value.log.map(({cid:t})=>u.make(this.id,t))}get anchorCommitIds(){return this.state$.value.log.filter(({type:t})=>t===K.ANCHOR).map(({cid:t})=>u.make(this.id,t))}get state(){return v(this.state$.value)}async sync(t={}){t={sync:f.PREFER_CACHE,...t};const e=await this.api.loadStream(this.id,t);this.state$.next(e.state)}async requestAnchor(){return this.api.requestAnchor(this.id)}}function X(){return n=>{}}function mn(n){const t=new AbortController;if(n.length===0)throw Error("Need abort signals to create a merged abort signal");return n.some(e=>e.aborted)?(t.abort(),t.signal):(ye(...n.map(e=>Lt(e,"abort"))).pipe(kt()).subscribe(()=>{t.abort()}),t.signal)}class hn{constructor(t){const e=new AbortController;if(this.signal=e.signal,t<=0){e.abort();return}this._subscription=Ft(t).subscribe(()=>{e.abort()})}clear(){this._subscription?.unsubscribe()}}async function fn(n,t){const e=new AbortController,r=()=>{e.abort()};return n.addEventListener("abort",r),n.aborted&&e.abort(),t(e.signal).finally(()=>{n.removeEventListener("abort",r)})}const pn=60*1e3*3;async function E(n,t={}){t.body&&Object.assign(t,{body:JSON.stringify(t.body),headers:{...t.headers,"Content-Type":"application/json"}});const e=t.timeout||pn,r=new hn(e),i=t.signal?mn([t.signal,r.signal]):r.signal,s=await fn(i,o=>jt(String(n),{...t,signal:o,credentials:"include"})).finally(()=>r.clear());if(!s.ok){const o=await s.text();throw new Error(`HTTP request to '${n}' failed with status '${s.statusText}': ${o}`)}return s.json()}function A(n){const t=D.asCID(n);if(t)return t;if(typeof n=="string")return D.parse(n);if(n instanceof Uint8Array)return D.decode(n);throw new Error(`${n} cannot be converted to a CID`)}const _t=0;class m{static streamIdFromState(t){return new c(t.type,t.log[0].cid)}static serializeCommit(t){const e=v(t);return m.isSignedCommitContainer(e)?(e.jws.link=e.jws.link.toString(),e.linkedBlock=T(e.linkedBlock,"base64"),e.cacaoBlock&&(e.cacaoBlock=T(e.cacaoBlock,"base64")),e):(m.isSignedCommit(t)&&(e.link=e.link.toString()),m.isAnchorCommit(t)&&(e.proof=e.proof.toString()),e.id&&(e.id=e.id.toString()),e.prev&&(e.prev=e.prev.toString()),t.header?.model&&(e.header.model=T(t.header.model,"base64")),e)}static deserializeCommit(t){const e=v(t);return m.isSignedCommitContainer(e)?(e.jws.link=A(e.jws.link),e.linkedBlock=C(e.linkedBlock,"base64"),e.cacaoBlock&&(e.cacaoBlock=C(e.cacaoBlock,"base64")),e):(m.isSignedCommit(e)&&(e.link=A(e.link)),m.isAnchorCommit(e)&&(e.proof=A(e.proof)),e.id&&(e.id=A(e.id)),e.prev&&(e.prev=A(e.prev)),e.header?.model&&(e.header.model=C(e.header.model,"base64")),e)}static serializeState(t){const e=v(t);return e.log=e.log.map(r=>({...r,cid:r.cid.toString()})),e.anchorStatus!=null&&(e.anchorStatus=z[e.anchorStatus]),e.anchorProof!=null&&(e.anchorProof.txHash=e.anchorProof.txHash.toString(),e.anchorProof.root=e.anchorProof.root.toString()),t.metadata?.model&&(e.metadata.model=t.metadata.model.toString()),t.next?.metadata?.model&&(e.next.metadata.model=t.next.metadata.model.toString()),t.metadata?.unique&&t.type!=_t&&(e.metadata.unique=T(e.metadata.unique,"base64")),e.doctype=$.nameByCode(e.type),e}static deserializeState(t){if(!t)return null;const e=v(t);return e.doctype&&(e.type=$.codeByName(e.doctype),delete e.doctype),e.log=e.log.map(r=>({...r,cid:A(r.cid)})),e.anchorProof&&(e.anchorProof.txHash=A(e.anchorProof.txHash),e.anchorProof.root=A(e.anchorProof.root)),e.anchorStatus&&(e.anchorStatus=z[e.anchorStatus]),t.metadata?.model&&(e.metadata.model=c.fromString(t.metadata.model)),t.next?.metadata?.model&&(e.next.metadata.model=c.fromString(t.next.metadata.model)),t.metadata?.unique&&t.type!=_t&&(e.metadata.unique=C(t.metadata.unique,"base64")),e}static statesEqual(t,e){return JSON.stringify(m.serializeState(t))===JSON.stringify(m.serializeState(e))}static isStateSupersetOf(t,e){if(t.log.length<e.log.length)return!1;for(const r in e.log)if(!t.log[r].cid.equals(e.log[r].cid))return!1;return!(t.log.length===e.log.length&&t.anchorStatus!=e.anchorStatus)}static assertCommitLinksToState(t,e){const r=this.streamIdFromState(t);if(e.id&&!e.id.equals(t.log[0].cid))throw new Error(`Invalid genesis CID in commit for StreamID ${r.toString()}. Found: ${e.id}, expected ${t.log[0].cid}`);const i=t.log[t.log.length-1].cid;if(!e.prev.equals(i))throw new Error(`Commit doesn't properly point to previous commit in log. Expected ${i}, found 'prev' ${e.prev}`)}static async convertCommitToSignedCommitContainer(t,e){if(m.isSignedCommit(t)){const r=await e.block.get(t.link);return{jws:t,linkedBlock:r}}return t}static isSignedCommitContainer(t){return t&&t.jws!==void 0}static isSignedCommit(t){return t&&t.link!==void 0}static isAnchorCommit(t){return t&&t.proof!==void 0}static isSignedCommitData(t){return t&&t.envelope!==void 0}static isAnchorCommitData(t){return t&&t.proof!==void 0}static commitDataToLogEntry(t,e){const r={cid:t.cid,type:e};return t?.capability?.p?.exp&&(r.expirationTime=Math.floor(Date.parse(t.capability.p.exp)/1e3)),t.timestamp&&(r.timestamp=t.timestamp),r}static checkForCacaoExpiration(t){const e=Math.floor(Date.now()/1e3);for(const r of t.log){const i=r.timestamp??e;if(r.expirationTime&&r.expirationTime<i)throw new Error(`CACAO expired: Commit ${r.cid.toString()} of Stream ${m.streamIdFromState(t).toString()} has a CACAO that expired at ${r.expirationTime}. Loading the stream with 'sync: SyncOptions.ALWAYS_SYNC' will restore the stream to a usable state, by discarding the invalid commits (this means losing the data from those invalid writes!)`)}}static anchorTimestampFromState(t){for(let e=t.log.length-1;e>=0;e--){const r=t.log[e];if(r.timestamp)return r.timestamp}return null}static validDIDString(t){return!(typeof t!="string"||!t.startsWith("did:"))}}function gn(n){if(typeof n=="string"&&n.includes("@")){const[t,e]=n.split("@");if(!t||!e)throw new Error("Invalid accountId provided");return new J({address:t,chainId:e})}return new J(n)}class yn extends we{next(t){const e=this.value;m.statesEqual(e,t)||super.next(t)}}var wn=globalThis&&globalThis.__decorate||function(n,t,e,r){var i=arguments.length,s=i<3?t:r===null?r=Object.getOwnPropertyDescriptor(t,e):r,o;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")s=Reflect.decorate(n,t,e,r);else for(var a=n.length-1;a>=0;a--)(o=n[a])&&(s=(i<3?o(s):i>3?o(t,e,s):o(t,e))||s);return i>3&&s&&Object.defineProperty(t,e,s),s},g;const et={anchor:!0,publish:!0,pin:!0,sync:f.PREFER_CACHE},En={sync:f.PREFER_CACHE},bt={anchor:!0,publish:!0};function nt(n,t){if(typeof n?.schema=="string")try{u.fromString(n.schema)}catch{throw new Error("Schema must be a CommitID")}const e={controllers:n?.controllers,family:n?.family,schema:n?.schema?.toString(),tags:n?.tags};if(t)n?.deterministic||(e.unique=T(dt.randomBytes(12),"base64")),n?.forbidControllerChange&&(e.forbidControllerChange=!0);else{if(n?.deterministic!==void 0||n?.unique!==void 0)throw new Error("Cannot change 'deterministic' or 'unique' properties on existing Streams");if(n?.forbidControllerChange!==void 0)throw new Error("Cannot change 'forbidControllerChange' property on existing Streams")}return Object.keys(e).forEach(r=>e[r]===void 0&&delete e[r]),e}async function Dt(n){if(!n.did)throw new Error("No DID provided");return n.did.authenticated||(await n.did.authenticate(),n.loggerProvider&&n.loggerProvider.getDiagnosticsLogger().imp(`Now authenticated as DID ${n.did.id}`)),n.did}async function rt(){throw new Error("Historical stream commits cannot be modified. Load the stream without specifying a commit to make updates.")}let x=g=class extends Z{constructor(){super(...arguments),this._isReadOnly=!1}get content(){return super.content}get metadata(){const{next:t,metadata:e}=this.state$.value;return v(t?.metadata??e)}get controllers(){return this.metadata.controllers}static async create(t,e,r,i={}){i={...et,...i},!r?.deterministic&&i.syncTimeoutSeconds==null&&(i.syncTimeoutSeconds=0);const s=i.asDID?{did:i.asDID}:t,o=await g.makeGenesis(s,e,r);return t.createStreamFromGenesis(g.STREAM_TYPE_ID,o,i)}static async createFromGenesis(t,e,r={}){r={...et,...r},e.header?.unique&&r.syncTimeoutSeconds==null&&(r.syncTimeoutSeconds=0);const i=e.data?await g._signDagJWS(t,e):e;return t.createStreamFromGenesis(g.STREAM_TYPE_ID,i,r)}static async deterministic(t,e,r={}){if(r={...et,...r},e={...e,deterministic:!0},e.family==null&&e.tags==null)throw new Error("Family and/or tags are required when creating a deterministic tile document");const i=await g.makeGenesis(t,null,e);return t.createStreamFromGenesis(g.STREAM_TYPE_ID,i,r)}static async load(t,e,r={}){r={...En,...r};const i=M.from(e);if(i.type!=g.STREAM_TYPE_ID)throw new Error(`StreamID ${i.toString()} does not refer to a '${g.STREAM_TYPE_NAME}' stream, but to a ${i.typeName}`);return t.loadStream(i,r)}async update(t,e,r={}){r={...bt,...r};const i=r.asDID?{did:r.asDID}:this.api,s=await this.makeCommit(i,t,e),o=await this.api.applyCommit(this.id,s,r);this.state$.next(o.state)}async patch(t,e={}){e={...bt,...e};const i={header:nt(this.metadata,!1),data:t,prev:this.tip,id:this.id.cid},s=await g._signDagJWS(this.api,i),o=await this.api.applyCommit(this.id,s,e);this.state$.next(o.state)}makeReadOnly(){this.update=rt,this.patch=rt,this.sync=rt,this._isReadOnly=!0}get isReadOnly(){return this._isReadOnly}async makeCommit(t,e,r){const i=await this._makeRawCommit(e,r);return g._signDagJWS(t,i)}async _makeRawCommit(t,e){e||(e={});const r=nt(e,!1);if(t==null&&(t=this.content),r.controllers){if(r.controllers.length!==1)throw new Error("Exactly one controller must be specified");if(!r.controllers[0])throw new Error("Controller cannot be updated to an undefined value.")}const i=qt.compare(this.content,t),s=this.state.log[0];return{header:r,data:i,prev:this.tip,id:s.cid}}static async makeGenesis(t,e,r){if(r||(r={}),!r.controllers||r.controllers.length===0)if(t.did){const o=await Dt(t);r.controllers=[o.hasParent?o.parent:o.id]}else throw new Error("No controllers specified");if(r.controllers?.length!==1)throw new Error("Exactly one controller must be specified");const i=nt(r,!0);if(r?.deterministic&&e)throw new Error("Initial content must be null when creating a deterministic Tile document");if(e==null){const o={header:i};return ut(o),o}const s={data:e,header:i};return g._signDagJWS(t,s)}static async _signDagJWS(t,e){return(await Dt(t)).createDagJWS(e)}};x.STREAM_TYPE_NAME="tile";x.STREAM_TYPE_ID=0;x=g=wn([X()],x);const Sn="https://ipfs.3box.io",_n=100,It=new Ce.LRUMap(_n),bn=async n=>{const t=It.get(n);if(t)return t;const e=await jt(n);if(e.ok){const r=await e.json();return It.set(n,r),r}else throw new Error("Not a valid 3ID")},Dn=n=>`${Sn}/did-doc?cid=${encodeURIComponent(n)}`,In={dag:{get:async n=>bn(Dn(n))}},Rt=(n,t)=>{const e=new Uint8Array(n.length+2);return t?e[0]=236:e[0]=231,e[1]=1,e.set(n,2),`z${T(e,"base58btc")}`},Rn=n=>{const t=n.slice(2,66);return`${(n.slice(66,130)&1)===0?"02":"03"}${t}`},Cn=async(n,t=In)=>{const e=(await t.dag.get(n)).value;let r,i;try{const d=e.publicKey.findIndex(y=>y.id.endsWith("signingKey")),l=e.publicKey.findIndex(y=>y.id.endsWith("encryptionKey"));r=e.publicKey[d].publicKeyHex,i=e.publicKey[l].publicKeyBase64}catch{throw new Error("Not a valid 3ID")}const s=Rn(r),o=Rt(C(s,"base16")),a=Rt(C(i,"base64pad"),!0);return{keyDid:`did:key:${o}`,publicKeys:{[o.slice(-15)]:o,[a.slice(-15)]:a}}},ie=n=>({didResolutionMetadata:n,didDocument:null,didDocumentMetadata:{}}),Tn=n=>n().catch(t=>ie({error:"invalidDid",message:t.toString()})),Ct="application/did+ld+json",ct="application/did+json",An=n=>{try{return D.parse(n),!0}catch{return!1}},Tt=n=>new Date(n*1e3).toISOString().split(".")[0]+"Z";function se(n,t){if(!(n&&n.publicKeys))return null;const e={id:t,verificationMethod:[],authentication:[],keyAgreement:[]};return Object.entries(n.publicKeys).reduce((r,[i,s])=>{const o=C(s.slice(1),"base58btc"),a={id:`${t}#${i}`,type:"",controller:t,publicKeyBase58:T(o.slice(2),"base58btc")};return o[0]===231?(a.type="EcdsaSecp256k1Signature2019",r.verificationMethod.push(a),r.authentication.push(a)):o[0]===236&&(a.type="X25519KeyAgreementKey2019",r.verificationMethod.push(a),r.keyAgreement.push(a)),r},e)}function vn(n){for(let t=n.length-1;t>=0;t--){const e=n[t];if(e.type===K.ANCHOR)return e}return n[0]}function $n(n,t){const e={},{timestamp:r,cid:i}=vn(n.log),{timestamp:s,cid:o}=t.log.find(({timestamp:a})=>a>r||!r&&a)||{};return r&&(e.updated=Tt(r)),s&&(e.nextUpdate=Tt(s)),i&&(e.versionId=n.log.length===1?"0":i?.toString()),o&&(e.nextVersionId=o.toString()),e}function Pn(n=""){const t=n.split("&").find(r=>r.includes("versionId")||r.includes("version-id")),e=n.split("&").find(r=>r.includes("versionTime"));return{commit:t?t.split("=")[1]:void 0,timestamp:e?Math.floor(new Date(e.split("=")[1]).getTime()/1e3):void 0}}const On=async(n,t,e)=>{const r=await Cn(t),i={controllers:[r.keyDid],family:"3id",deterministic:!0},s=(await x.create(n,null,i,{anchor:!1,publish:!1})).id,o=await oe(n,s.toString(),e,t);return o.didDocument===null&&(o.didDocument=se(r,`did:3:${t}`)),o},oe=async(n,t,e,r)=>{const i=c.fromString(t);let s;const o=[{streamId:i}];e.commit?(s=u.make(i,e.commit),o.push({streamId:s})):e.timestamp&&o.push({streamId:i,atTime:e.timestamp});const a=await n.multiQuery(o);if(!a[t])throw new Error(`Failed to properly resolve 3ID, stream ${t} not found in response.`);const d=a[t].state,l=s?.toString()||Object.keys(a).find(de=>de!==t),y=a[l]?.state||d,h=$n(y,d),ft=a[l||t];if(l&&!ft)throw new Error(`No resolution for commit ${l}`);const ae=ft.state.content,ce=se(ae,`did:3:${r||t}`);return{didResolutionMetadata:{contentType:ct},didDocument:ce,didDocumentMetadata:h}};function wr(n){return{3:(t,e,r,i)=>Tn(async()=>{const s=i.accept||ct,o=Pn(e.query),a=e.id,d=()=>An(a)?On(n,a,o):oe(n,a,o);switch(s){case ct:return d();case Ct:{const l=await d();return l.didDocument["@context"]="https://www.w3.org/ns/did/v1",l.didResolutionMetadata.contentType=Ct,l}default:return ie({error:"representationNotSupported"})}})}}function At(n){return typeof n=="string"?c.fromString(n):n}function Mn(n,t){const e=new URL(n);for(const[r,i]of Object.entries(t))c.isInstance(i)?e.searchParams.set(r,i.toString()):typeof i=="object"?e.searchParams.set(r,JSON.stringify(i)):e.searchParams.set(r,i);return e}function vt(n){const t={};for(const[e,r]of Object.entries(n))c.isInstance(r)?t[e]=r.toString():t[e]=r;return t}class w extends Ut{constructor(t,e,r){super(i=>{this.state$.observers.length===0&&(this.periodicSubscription=Ft(0,r).pipe(Ee(()=>this._syncState(this.id,{sync:f.PREFER_CACHE}))).subscribe()),this.state$.subscribe(i).add(()=>{this.state$.observers.length===0&&this.periodicSubscription?.unsubscribe()})}),this.state$=new yn(t),this._apiUrl=new URL(e)}get value(){return this.state$.value}get state(){return this.state$.value}next(t){this.state$.next(t)}async _syncState(t,e){const r=await w._load(t,this._apiUrl,e);this.state$.next(m.deserializeState(r))}get id(){return new c(this.state$.value.type,this.state$.value.log[0].cid)}static async createFromGenesis(t,e,r,i,s){const o=new URL("./streams",t),{state:a}=await E(o,{method:"post",body:{type:e,genesis:m.serializeCommit(r),opts:i}});return new w(m.deserializeState(a),t,s)}static async applyCommit(t,e,r,i,s){const o=new URL("./commits",t),{state:a}=await E(o,{method:"post",body:{streamId:e.toString(),commit:m.serializeCommit(r),opts:i}});return new w(m.deserializeState(a),t,s)}static async _load(t,e,r){const i=Mn(new URL(`./streams/${t}`,e),r),{state:s}=await E(i);return s}static async load(t,e,r,i){const s=await w._load(t,e,i);return new w(m.deserializeState(s),e,r)}static async loadStreamCommits(t,e){const r=new URL(`./commits/${t}`,e),{commits:i}=await E(r);return i.map(s=>({cid:s.cid,value:m.deserializeCommit(s.value)}))}complete(){this.state$.complete()}}var xn=globalThis&&globalThis.__decorate||function(n,t,e,r){var i=arguments.length,s=i<3?t:r===null?r=Object.getOwnPropertyDescriptor(t,e):r,o;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")s=Reflect.decorate(n,t,e,r);else for(var a=n.length-1;a>=0;a--)(o=n[a])&&(s=(i<3?o(s):i>3?o(t,e,s):o(t,e))||s);return i>3&&s&&Object.defineProperty(t,e,s),s},O;const it=()=>{throw new Error("Historical stream commits cannot be modified. Load the stream without specifying a commit to make updates.")},$t={anchor:!1,publish:!0,pin:!0,sync:f.PREFER_CACHE},st={anchor:!0,publish:!0},Nn={sync:f.PREFER_CACHE};let F=O=class extends Z{constructor(){super(...arguments),this._isReadOnly=!1}get did(){return this.content}get metadata(){const{next:t,metadata:e}=this.state$.value;return v(t?.metadata??e)}get controllers(){return this.metadata.controllers}static async fromAccount(t,e,r={}){r={...$t,...r};const i=gn(e),s=O.makeGenesis(i);return O.fromGenesis(t,s,r)}static async fromGenesis(t,e,r={}){return r={...$t,...r},t.createStreamFromGenesis(O.STREAM_TYPE_ID,e,r)}async setDid(t,e,r={}){r={...st,...r};const i=typeof t=="string"?t.trim():t.id;if(Ae(i)?.did!==i)throw new Error(`DID is not valid: '${i}'`);const o=await e.createLink(i);return this.setDidProof(o,r)}async setDidProof(t,e={}){e={...st,...e};const r=this.makeCommit(t),i=await this.api.applyCommit(this.id,r,e);this.state$.next(i.state)}async clearDid(t,e={}){e={...st,...e};const r=await t.createLink("");return this.setDidProof(r,e)}static async load(t,e,r={}){r={...Nn,...r};const i=M.from(e);if(i.type!=O.STREAM_TYPE_ID)throw new Error(`StreamID ${i.toString()} does not refer to a '${O.STREAM_TYPE_NAME}' stream, but to a ${i.typeName}`);return t.loadStream(i,r)}static makeGenesis(t){return t.chainId.namespace==="eip155"&&(t.address=t.address.toLowerCase()),{header:{controllers:[`${t.address}@${t.chainId.toString()}`],family:`caip10-${t.chainId.toString()}`}}}makeCommit(t){return{data:t,prev:this.tip,id:this.id.cid}}makeReadOnly(){this.setDidProof=it,this.setDid=it,this.sync=it,this._isReadOnly=!0}get isReadOnly(){return this._isReadOnly}};F.STREAM_TYPE_NAME="caip10-link";F.STREAM_TYPE_ID=1;F=O=xn([X()],F);var Ln=globalThis&&globalThis.__decorate||function(n,t,e,r){var i=arguments.length,s=i<3?t:r===null?r=Object.getOwnPropertyDescriptor(t,e):r,o;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")s=Reflect.decorate(n,t,e,r);else for(var a=n.length-1;a>=0;a--)(o=n[a])&&(s=(i<3?o(s):i>3?o(t,e,s):o(t,e))||s);return i>3&&s&&Object.defineProperty(t,e,s),s},_;const kn={sync:f.PREFER_CACHE};async function Pt(n){if(n.did==null)throw new Error("No DID provided");n.did.authenticated||(await n.did.authenticate(),n.loggerProvider&&n.loggerProvider.getDiagnosticsLogger().imp(`Now authenticated as DID ${n.did.id}`))}async function Un(){throw new Error("Historical stream commits cannot be modified. Load the stream without specifying a commit to make updates.")}let N=_=class extends Z{constructor(){super(...arguments),this._isReadOnly=!1}get content(){return super.content}get metadata(){return{controller:this.state$.value.metadata.controllers[0],model:_.MODEL}}static async create(t,e,r){_.assertComplete(e),_.assertRelationsValid(e);const i={publish:!0,anchor:!0,pin:!0,sync:f.NEVER_SYNC},s=await _._makeGenesis(t,e,r);return await t.createStreamFromGenesis(_.STREAM_TYPE_ID,s,i)}static assertComplete(t,e){if(!t.name)throw e?new Error(`Model with StreamID ${e.toString()} is missing a 'name' field`):new Error("Model is missing a 'name' field");if(!t.schema)throw e?new Error(`Model ${t.name} (${e.toString()}) is missing a 'schema' field`):new Error(`Model ${t.name} is missing a 'schema' field`);if(!t.accountRelation)throw e?new Error(`Model ${t.name} (${e.toString()}) is missing a 'accountRelation' field`):new Error(`Model ${t.name} is missing a 'accountRelation' field`)}static assertRelationsValid(t){if(!!t.relations)for(const[e,r]of Object.entries(t.relations))switch(r.type){case"account":continue;case"document":try{c.fromString(r.model)}catch(i){throw new Error(`Relation on field ${e} has invalid model: ${i.toString()}`)}continue;default:throw new Error(`Relation on field ${e} has unexpected type ${r.type}`)}}static async load(t,e,r={}){r={...kn,...r};const i=M.from(e);if(i.type!=_.STREAM_TYPE_ID)throw new Error(`StreamID ${i.toString()} does not refer to a '${_.STREAM_TYPE_NAME}' stream, but to a ${i.typeName}`);return await t.loadStream(i,r)}static async _makeGenesis(t,e,r){const i=await this._makeRawGenesis(t,e,r);return _._signDagJWS(t,i)}static async _makeRawGenesis(t,e,r){if(e==null)throw new Error("Genesis content cannot be null");if(!r||!r.controller)if(t.did)await Pt(t),r={controller:t.did.hasParent?t.did.parent:t.did.id};else throw new Error("No controller specified");const i={controllers:[r.controller],model:_.MODEL.bytes,sep:"model"};return{data:e,header:i}}makeReadOnly(){this.sync=Un,this._isReadOnly=!0}get isReadOnly(){return this._isReadOnly}static async _signDagJWS(t,e){return await Pt(t),t.did.createDagJWS(e)}};N.STREAM_TYPE_NAME="model";N.STREAM_TYPE_ID=2;N.MODEL=function(){const n=ut("model-v1"),t=ve.encode(n,"identity"),e=Re(pt,t),r=D.createV1(pt,e);return new c("UNLOADABLE",r)}();N=_=Ln([X()],N);var Fn=globalThis&&globalThis.__decorate||function(n,t,e,r){var i=arguments.length,s=i<3?t:r===null?r=Object.getOwnPropertyDescriptor(t,e):r,o;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")s=Reflect.decorate(n,t,e,r);else for(var a=n.length-1;a>=0;a--)(o=n[a])&&(s=(i<3?o(s):i>3?o(t,e,s):o(t,e))||s);return i>3&&s&&Object.defineProperty(t,e,s),s},b;const jn={anchor:!0,publish:!0,pin:!0,sync:f.NEVER_SYNC,syncTimeoutSeconds:0},qn={anchor:!1,publish:!1,pin:!0,sync:f.PREFER_CACHE},Bn={sync:f.PREFER_CACHE},Ot={anchor:!0,publish:!0};async function Mt(n){if(n.did==null)throw new Error("No DID provided");n.did.authenticated||(await n.did.authenticate(),n.loggerProvider&&n.loggerProvider.getDiagnosticsLogger().imp(`Now authenticated as DID ${n.did.id}`))}async function ot(){throw new Error("Historical stream commits cannot be modified. Load the stream without specifying a commit to make updates.")}let j=b=class extends Z{constructor(){super(...arguments),this._isReadOnly=!1}get content(){return super.content}get metadata(){const t=this.state$.value.metadata;return{controller:t.controllers[0],model:t.model}}static async create(t,e,r,i={}){i={...jn,...i};const s=i.asDID?{did:i.asDID}:t,o=await b._makeGenesis(s,e,r);return t.createStreamFromGenesis(b.STREAM_TYPE_ID,o,i)}static async single(t,e,r={}){r={...qn,...r};const i=r.asDID?{did:r.asDID}:t;e={...e,deterministic:!0};const s=await b._makeGenesis(i,null,e);return t.createStreamFromGenesis(b.STREAM_TYPE_ID,s,r)}static async load(t,e,r={}){r={...Bn,...r};const i=M.from(e);if(i.type!=b.STREAM_TYPE_ID)throw new Error(`StreamID ${i.toString()} does not refer to a '${b.STREAM_TYPE_NAME}' stream, but to a ${i.typeName}`);return t.loadStream(i,r)}async replace(t,e={}){e={...Ot,...e};const r=e.asDID?{did:e.asDID}:this.api,i=await this._makeCommit(r,t),s=await this.api.applyCommit(this.id,i,e);this.state$.next(s.state)}async patch(t,e={}){e={...Ot,...e};const r={data:t,prev:this.tip,id:this.id.cid},i=await b._signDagJWS(this.api,r),s=await this.api.applyCommit(this.id,i,e);this.state$.next(s.state)}makeReadOnly(){this.replace=ot,this.patch=ot,this.sync=ot,this._isReadOnly=!0}get isReadOnly(){return this._isReadOnly}_makeCommit(t,e){const r=this._makeRawCommit(e);return b._signDagJWS(t,r)}_makeRawCommit(t){return{data:qt.compare(this.content,t||{}),prev:this.tip,id:this.state.log[0].cid}}static async _makeGenesis(t,e,r){const i=await this._makeRawGenesis(t,e,r);return r.deterministic?(ut(i),i):b._signDagJWS(t,i)}static async _makeRawGenesis(t,e,r){if(!r.model)throw new Error("Must specify a 'model' when creating a ModelInstanceDocument");let i=r.controller;if(!i)if(t.did)await Mt(t),i=t.did.hasParent?t.did.parent:t.did.id;else throw new Error("No controller specified");const s={controllers:[i],model:r.model.bytes,sep:"model"};return r.deterministic||(s.unique=dt.randomBytes(12)),{data:e,header:s}}static async _signDagJWS(t,e){return await Mt(t),t.did.createDagJWS(e)}};j.STREAM_TYPE_NAME="MID";j.STREAM_TYPE_ID=3;j=b=Fn([X()],j);class Gn{constructor(t){this._apiUrl=t}async add(t,e){const r={};e&&(r.force=!0);const i=new URL(`./pins/${t}`,this._apiUrl);await E(i,{method:"post",body:r})}async rm(t,e){const r=new URL(`./pins/${t}`,this._apiUrl);await E(r,{method:"delete",body:{opts:e}})}async ls(t){let e=new URL("./pins",this._apiUrl);t&&(e=new URL(`./pins/${t.toString()}`,this._apiUrl));const r=await E(e),{pinnedStreamIds:i}=r;return{[Symbol.asyncIterator](){let s=0;return{next(){return s===i.length?Promise.resolve({value:null,done:!0}):Promise.resolve({value:i[s++],done:!1})}}}}}}class Yn{constructor(t){this._fetchJson=E,this._collectionURL=new URL("./collection",t),this._countURL=new URL("./collection/count",t)}async count(t){return(await this._fetchJson(this._countURL,{method:"POST",body:vt(t)})).count}async query(t){const e=await this._fetchJson(this._collectionURL,{method:"POST",body:vt(t)});return{edges:e.edges.map(i=>({cursor:i.cursor,node:m.deserializeState(i.node)})),pageInfo:e.pageInfo}}}class Hn extends Error{constructor(){super("Failed to get DID.  Please make sure your Ceramic client has an authenticated DID attached")}}class Jn{constructor(t,e){this._apiUrl=t,this._getDidFn=e,this._fetchJson=E,this.modelsPath="./admin/models",this.getCodePath="./admin/getCode"}getCodeUrl(){return new URL(this.getCodePath,this._apiUrl)}getModelsUrl(){return new URL(this.modelsPath,this._apiUrl)}async buildJWS(t,e,r){if(!t)throw new Hn;const i=r?{models:r.map(o=>o.toString())}:void 0,s=await t.createJWS({code:e,requestPath:this.getModelsUrl().pathname,requestBody:i});return`${s.signatures[0].protected}.${s.payload}.${s.signatures[0].signature}`}async generateCode(){return(await this._fetchJson(this.getCodeUrl())).code}async startIndexingModels(t){const e=await this.generateCode();await this._fetchJson(this.getModelsUrl(),{method:"post",body:{jws:await this.buildJWS(this._getDidFn(),e,t)}})}async getIndexedModels(){const t=await this.generateCode();return(await this._fetchJson(this.getModelsUrl(),{headers:{Authorization:`Basic ${await this.buildJWS(this._getDidFn(),t)}`}})).models.map(r=>c.fromString(r))}async stopIndexingModels(t){const e=await this.generateCode();await this._fetchJson(this.getModelsUrl(),{method:"delete",body:{jws:await this.buildJWS(this._getDidFn(),e,t)}})}}const Wn="/api/v0/",zn="http://localhost:7007",Kn={syncInterval:5e3},Vn={anchor:!0,publish:!0,sync:f.PREFER_CACHE},Qn={anchor:!0,publish:!0,sync:f.PREFER_CACHE},xt={sync:f.PREFER_CACHE};class br{constructor(t=zn,e={}){this._config={...Kn,...e},this._apiUrl=new URL(Wn,t),this.context={api:this},this.pin=new Gn(this._apiUrl),this.index=new Yn(this._apiUrl);const r=(()=>this.did).bind(this);this.admin=new Jn(this._apiUrl,r),this._streamConstructors={[F.STREAM_TYPE_ID]:F,[N.STREAM_TYPE_ID]:N,[j.STREAM_TYPE_ID]:j,[x.STREAM_TYPE_ID]:x}}get did(){return this.context.did}set did(t){this.context.did=t}async createStreamFromGenesis(t,e,r={}){r={...Qn,...r};const i=await w.createFromGenesis(this._apiUrl,t,e,r,this._config.syncInterval);return this.buildStreamFromDocument(i)}async loadStream(t,e={}){e={...xt,...e};const r=M.from(t),i=await w.load(r,this._apiUrl,this._config.syncInterval,e);return this.buildStreamFromDocument(i)}async multiQuery(t,e){const r=t.map(o=>({...o,streamId:typeof o.streamId=="string"?o.streamId:o.streamId.toString()})),i=new URL("./multiqueries",this._apiUrl),s=await E(i,{method:"post",body:{queries:r,timeout:e}});return Object.entries(s).reduce((o,a)=>{const[d,l]=a,y=m.deserializeState(l),h=new w(y,this._apiUrl,this._config.syncInterval);return o[d]=this.buildStreamFromDocument(h),o},{})}loadStreamCommits(t){const e=At(t);return w.loadStreamCommits(e,this._apiUrl)}async applyCommit(t,e,r={}){r={...Vn,...r};const i=At(t),s=await w.applyCommit(this._apiUrl,i,e,r,this._config.syncInterval);return this.buildStreamFromDocument(s)}async requestAnchor(t,e={}){e={...xt,...e};const{anchorStatus:r}=await E(`${this._apiUrl}/streams/${t.toString()}/anchor`,{method:"post",body:{opts:e}});return r}addStreamHandler(t){this._streamConstructors[t.name]=t.stream_constructor}buildStreamFromState(t){const e=new w(t,this._apiUrl,this._config.syncInterval);return this.buildStreamFromDocument(e)}buildStreamFromDocument(t){const e=t.state.type,r=this._streamConstructors[e];if(!r)throw new Error(`Failed to find constructor for stream ${e}`);return new r(t,this.context)}async setDID(t){this.context.did=t}async getSupportedChains(){if(this._supportedChains)return this._supportedChains;const{supportedChains:t}=await E(this._apiUrl+"/node/chains");return this._supportedChains=t,t}async close(){}}export{u as C,Qt as E,c as S,x as T,re as a,pr as b,gr as c,M as d,F as e,br as f,wr as g};
