function c(n){return n>=0?n:-n}function w(n,t){if(typeof n=="number"&&(n=BigInt(n)),typeof t=="number"&&(t=BigInt(t)),n<=0n||t<=0n)throw new RangeError("a and b MUST be > 0");let r=0n,e=1n,o=1n,i=0n;for(;n!==0n;){const u=t/n,g=t%n,m=r-o*u,s=e-i*u;t=n,n=g,r=o,e=i,o=m,i=s}return{g:t,x:r,y:e}}function f(n,t){if(typeof n=="number"&&(n=BigInt(n)),typeof t=="number"&&(t=BigInt(t)),t<=0n)throw new RangeError("n must be > 0");const r=n%t;return r<0n?r+t:r}function l(n,t){const r=w(f(n,t),t);if(r.g!==1n)throw new RangeError(`${n.toString()} does not have inverse modulo ${t.toString()}`);return f(r.x,t)}function y(n,t,r){if(typeof n=="number"&&(n=BigInt(n)),typeof t=="number"&&(t=BigInt(t)),typeof r=="number"&&(r=BigInt(r)),r<=0n)throw new RangeError("n must be > 0");if(r===1n)return 0n;if(n=f(n,r),t<0n)return l(y(n,c(t),r),r);let e=1n;for(;t>0;)t%2n===1n&&(e=e*n%r),t=t/2n,n=n**2n%r;return e}export{y as m};
