import{d as Z}from"./dataloader-a32e8ed0.js";import{T as M,C as L,S as $,d as B}from"./@ceramicnetwork-a15705dd.js";function K(n,t){if(t.has(n))throw new TypeError("Cannot initialize the same private elements twice on an object")}function J(n,t){return t.get?t.get.call(n):t.value}function Y(n,t,e){if(t.set)t.set.call(n,e);else{if(!t.writable)throw new TypeError("attempted to set read only private field");t.value=e}}function U(n,t,e){if(!t.has(n))throw new TypeError("attempted to "+e+" private field on non-instance");return t.get(n)}function S(n,t){var e=U(n,t,"get");return J(n,e)}function G(n,t,e){K(n,t),t.set(n,e)}function O(n,t,e){var i=U(n,t,"set");return Y(n,i,e),e}function tt(n){return typeof n=="string"||L.isInstance(n)||$.isInstance(n)?{streamId:n}:{streamId:n.streamId,genesis:n.genesis}}function T(n){return typeof n=="string"?B.from(n).toString():L.isInstance(n)||$.isInstance(n)?n.toString():n.streamId.toString()}async function z(n){const t=await M.makeGenesis({},null,{...n,deterministic:!0}),e=await $.fromGenesis("tile",t);return{genesis:t,streamId:e}}const et=()=>Promise.resolve([]);var D=new WeakMap,F=new WeakMap;class V extends Z{cache(t){if(!S(this,F))return!1;const e=t.id.toString();return this.clear(e).prime(e,t),!0}async create(t,e,i){const r=await M.create(S(this,D),t,e,i);return this.cache(r),r}async deterministic(t,e){const i=await z(t);try{return await super.load(i)}catch{const a=await M.createFromGenesis(S(this,D),i.genesis,e);return this.cache(a),a}}async load(t){return await super.load(t)}async update(t,e,i,r){const a=T(t);this.clear(a);const s=await this.load({streamId:a});return await s.update(e,i,r),s}constructor(t){super(et,{cache:!0,cacheKeyFn:T,cacheMap:t.cache!=null&&typeof t.cache!="boolean"?t.cache:void 0}),G(this,D,{writable:!0,value:void 0}),G(this,F,{writable:!0,value:void 0}),this._batchLoadFn=async e=>{t.cache||this.clearAll();const i=await t.ceramic.multiQuery(e.map(tt),t.multiqueryTimeout);return e.map(r=>{const a=T(r),s=i[a];return s||new Error(`Failed to load stream: ${a}`)})},O(this,D,t.ceramic),O(this,F,!!t.cache)}}function nt(n,t){if(t.has(n))throw new TypeError("Cannot initialize the same private elements twice on an object")}function it(n,t){return t.get?t.get.call(n):t.value}function at(n,t,e){if(t.set)t.set.call(n,e);else{if(!t.writable)throw new TypeError("attempted to set read only private field");t.value=e}}function Q(n,t,e){if(!t.has(n))throw new TypeError("attempted to "+e+" private field on non-instance");return t.get(n)}function w(n,t){var e=Q(n,t,"get");return it(n,e)}function X(n,t,e){nt(n,t),t.set(n,e)}function C(n,t,e){var i=Q(n,t,"set");return at(n,i,e),e}var g=new WeakMap,y=new WeakMap;class q{get aliases(){return w(this,g)}get loader(){return w(this,y)}getDefinitionID(t){return w(this,g).definitions[t]??null}getSchemaURL(t){return w(this,g).schemas[t]??null}getTileID(t){return w(this,g).tiles[t]??null}async loadTile(t){const e=this.getTileID(t);if(e==null)throw new Error(`Tile alias "${t}" is not defined`);return await w(this,y).load(e)}async createTile(t,e,i={}){const r=this.getSchemaURL(t);if(r==null)throw new Error(`Schema alias "${t}" is not defined`);const{controller:a,...s}=i,c={schema:r};return a!=null&&(c.controllers=[a]),await w(this,y).create(e,c,s)}constructor(t){if(X(this,g,{writable:!0,value:void 0}),X(this,y,{writable:!0,value:void 0}),C(this,g,t.aliases),t.loader!=null)C(this,y,t.loader);else{if(t.ceramic==null)throw new Error("Invalid DataModel parameters: missing ceramic or loader");C(this,y,new V({ceramic:t.ceramic,cache:t.cache}))}}}const rt="ceramic://k3y52l7qbv1fry1fp4s0nwdarh0vahusarpposgevy0pemiykymd2ord6swtharcw",k="ceramic://k3y52l7qbv1fryjn62sggjh1lpn11c56qfofzmty190d62hwk1cal1c7qc5he54ow";function st(n,t){if(t.has(n))throw new TypeError("Cannot initialize the same private elements twice on an object")}function ct(n,t){return t.get?t.get.call(n):t.value}function ot(n,t,e){if(t.set)t.set.call(n,e);else{if(!t.writable)throw new TypeError("attempted to set read only private field");t.value=e}}function N(n,t,e){if(!t.has(n))throw new TypeError("attempted to "+e+" private field on non-instance");return t.get(n)}function u(n,t){var e=N(n,t,"get");return ct(n,e)}function I(n,t,e){st(n,t),t.set(n,e)}function p(n,t,e){var i=N(n,t,"set");return ot(n,i,e),e}var v=new WeakMap,m=new WeakMap,A=new WeakMap,R=new WeakMap;class lt{_createValuePromise(){p(this,A,new Promise((t,e)=>{p(this,R,{resolve:t,reject:e})}))}change(t){return new Promise((e,i)=>{const r=async a=>{try{const s=await t(a);e(),this._next(s)}catch(s){i(s),this._next(a)}};u(this,m).push({reject:i,run:r}),u(this,m).length===1&&this._start()})}async changeContent(t){const e=async i=>(await i.update(t(i.content),i.metadata),i);return await this.change(e)}async get(){return u(this,m).length===0?await u(this,v).call(this):await u(this,A)}async _start(){try{const t=await u(this,v).call(this);this._next(t)}catch(t){u(this,m).forEach(e=>{e.reject(t)}),p(this,m,[]),u(this,R).reject(t),this._createValuePromise()}}_next(t){const e=u(this,m).shift();e==null?this._end(t):e.run(t)}_end(t){u(this,R).resolve(t),this._createValuePromise()}constructor(t){I(this,v,{writable:!0,value:void 0}),I(this,m,{writable:!0,value:[]}),I(this,A,{writable:!0,value:void 0}),I(this,R,{writable:!0,value:void 0}),p(this,v,t),this._createValuePromise()}}const ut=/^did:([A-Za-z0-9]+):([A-Za-z0-9.\-:_]+)$/;function ht(n){return ut.test(n)}function dt(n){if(!ht(n))throw new Error(`Invalid DID: ${n}`)}function j(n){return dt(n),{controllers:[n],family:"IDX"}}function ft(n,t){if(t.has(n))throw new TypeError("Cannot initialize the same private elements twice on an object")}function wt(n,t){return t.get?t.get.call(n):t.value}function mt(n,t,e){if(t.set)t.set.call(n,e);else{if(!t.writable)throw new TypeError("attempted to set read only private field");t.value=e}}function H(n,t,e){if(!t.has(n))throw new TypeError("attempted to "+e+" private field on non-instance");return t.get(n)}function o(n,t){var e=H(n,t,"get");return wt(n,e)}function _(n,t,e){ft(n,t),t.set(n,e)}function x(n,t,e){var i=H(n,t,"set");return mt(n,i,e),e}var f=new WeakMap,P=new WeakMap,W=new WeakMap,h=new WeakMap,E=new WeakMap;class _t{get authenticated(){return o(this,f).did!=null}get ceramic(){return o(this,f)}get id(){if(o(this,P)!=null)return o(this,P);if(o(this,f).did==null)throw new Error("Ceramic instance is not authenticated");return o(this,f).did.hasParent?o(this,f).did.parent:o(this,f).did.id}get loader(){return o(this,h)}get model(){return o(this,E)}async has(t,e){const i=this.getDefinitionID(t);return await this.getRecordID(i,e)!=null}async get(t,e){const i=this.getDefinitionID(t);return await this.getRecord(i,e)}async getMultiple(t,e){const i=this.getDefinitionID(t),r=await Promise.all(e.map(async c=>{const{genesis:l,streamId:d}=await z(j(c));return{genesis:l,streamId:d.toString(),paths:[i]}})),a=await o(this,f).multiQuery(r),s=[];for(const c of r){const l=a[c.streamId]?.content?.[i],d=l?a[$.fromString(l).toString()]:null;s.push(d?.content??null)}return s}async set(t,e,i={}){const r=this.getDefinitionID(t),[a,s]=await this._setRecordOnly(r,e,i);return a&&await this._setReference(i.controller??this.id,r,s),s}async merge(t,e,i={}){const r=this.getDefinitionID(t),a=await this.getRecord(r),s=a?{...a,...e}:e;return await this.setRecord(r,s,i)}async setAll(t,e={}){const i=Object.entries(t).map(async([s,c])=>{const l=this.getDefinitionID(s),[d,b]=await this._setRecordOnly(l,c,e);return[d,l,b]}),a=(await Promise.all(i)).reduce((s,[c,l,d])=>(c&&(s[l]=d.toUrl()),s),{});return await this._setReferences(e.controller??this.id,a),a}async setDefaults(t,e={}){const i=await this.getIndex()??{},r=Object.entries(t).map(([c,l])=>[this.getDefinitionID(c),l]).filter(c=>i[c[0]]==null).map(async([c,l])=>{const d=await this.getDefinition(c),b=await this._createRecord(d,l,e);return{[c]:b.toUrl()}}),s=(await Promise.all(r)).reduce((c,l)=>Object.assign(c,l),{});return await this._setReferences(e.controller??this.id,s),s}async remove(t,e=this.id){await this._getIndexProxy(e).changeContent(i=>(i!=null&&delete i[this.getDefinitionID(t)],i))}async getIndex(t=this.id){const e=this.authenticated&&t===this.id?await this._getIndexProxy(t).get():await this._getIDXDoc(t);return e?e.content:null}iterator(t){let e,i=0;return{[Symbol.asyncIterator](){return this},next:async()=>{if(e==null){const c=await this.getIndex(t);e=Object.entries(c??{})}if(i===e.length)return{done:!0,value:null};const[r,a]=e[i++],s=await o(this,h).load(a);return{done:!1,value:{key:r,id:a,record:s.content}}}}}async _createIDXDoc(t){return await o(this,h).deterministic(j(t))}async _getIDXDoc(t){const e=await this._createIDXDoc(t);if(e.content==null||e.metadata.schema==null)return null;if(e.metadata.schema!==k)throw new Error("Invalid document: schema is not IdentityIndex");return e}async _getOwnIDXDoc(t){const e=await this._createIDXDoc(t);if(e.content==null||e.metadata.schema==null)await e.update({},{schema:k});else if(e.metadata.schema!==k)throw new Error("Invalid document: schema is not IdentityIndex");return e}_getIndexProxy(t){let e=o(this,W)[t];return e==null&&(e=new lt(async()=>await this._getOwnIDXDoc(t)),o(this,W)[t]=e),e}getDefinitionID(t){return o(this,E).getDefinitionID(t)??t}async getDefinition(t){const e=await o(this,h).load(t);if(e.metadata.schema!==rt)throw new Error("Invalid document: schema is not Definition");return{...e.content,id:e.id}}async getRecordID(t,e){return(await this.getIndex(e??this.id))?.[t]??null}async getRecordDocument(t,e){const i=await this.getRecordID(t,e);return i?await o(this,h).load(i):null}async getRecord(t,e){const i=await this.getRecordDocument(t,e);return i?i.content:null}async setRecord(t,e,i={}){const[r,a]=await this._setRecordOnly(t,e,i);return r&&await this._setReference(i.controller??this.id,t,a),a}async _setRecordOnly(t,e,i){const r=await this.getRecordID(t,i.controller??this.id);if(r==null){const a=await this.getDefinition(t),s=await this._createRecord(a,e,i);return[!0,s]}else{const a=await o(this,h).update(r,e);return[!1,a.id]}}async _createRecord(t,e,{controller:i,pin:r}){const a=await o(this,h).deterministic({controllers:[i??this.id],family:t.id.toString()},{pin:r});return await a.update(e,{schema:t.schema}),a.id}async _setReference(t,e,i){await this._getIndexProxy(t).changeContent(r=>({...r,[e]:i.toUrl()}))}async _setReferences(t,e){Object.keys(e).length!==0&&await this._getIndexProxy(t).changeContent(i=>({...i,...e}))}constructor(t){_(this,f,{writable:!0,value:void 0}),_(this,P,{writable:!0,value:void 0}),_(this,W,{writable:!0,value:{}}),_(this,h,{writable:!0,value:void 0}),_(this,E,{writable:!0,value:void 0});const{cache:e,ceramic:i,id:r,loader:a,model:s}=t;x(this,f,i),x(this,P,r),x(this,h,a??new V({ceramic:i,cache:e})),x(this,E,s instanceof q?s:new q({loader:o(this,h),aliases:s}))}}export{q as D,V as T,_t as a,ht as i};
